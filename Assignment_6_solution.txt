Q1. -

class Solution:
    def Perm_Match(self, s: str) -> list[int]:
        x = 0
        y = len(s)
        result = []
        for i in s:
            if i == "I":
                result.append(x)
                x += 1
            else:
                result.append(y)
                y -= 1
        return result + [y]

f = Solution()
print(f.Perm_Match("IDID"))

Q2. -

class Solution:
    def Find_Target_Value(self, matrix: list[list[int]], target: int) -> bool:
        m = len(matrix)
        n = len(matrix[0])
        x = m - 1
        y = 0
        while x >= 0 and y < n:
            if matrix[x][y] == target:
                return True
            if matrix[x][y] > target:
                x -= 1
            else:
                y += 1
        return False

f = Solution()
print(f.Find_Target_Value())

Q3. -

class Solution:
    def Mountain_Array(self, arr: list[int]) -> bool:
        if len(arr) < 3:
            return False
        index = 0
        for index in range(1, len(arr)):
            if arr[index] <= arr[index-1]:
                break
        if index == len(arr) or index == 1:
            return False
        while index < len(arr):
            if arr[index] >= arr[index-1]:
                break
            index += 1
        return index == len(arr)

f = Solution()
print(f.Mountain_Array())

Q4. -

class Solution:
    def Maximum_Binary_Subarray(self, arr: list[int]) -> int:
        count = 0
        highest_count = count
        for x in range(len(arr)-1):
            if arr[x] == 0:
                break
        i = x
        while i < len(arr):
            if highest_count < count:
                highest_count = count

            if arr[i] == 0 or arr[i] == 1:
                count += 1
            else:
                count = 0
            i += 1

        return highest_count

f = Solution()
print(f.Maximum_Binary_Subarray())

Q5. -

class Solution:
    def Minimum_Product(self, arr1: list[int], arr2: list[int]) -> int:

        arr1.sort()
        arr2.sort()
        product = 0
        j = len(arr2)-1
        for i in range(len(arr1)):
            arr1[i] *= arr2[j]
            product += arr1[i]
            j -= 1
        return product

f = Solution()
print(f.Minimum_Product())

Q6. -

class Solution:
    def Extract_Original(self, arr: list[int]) -> list[int]:
        numFreq = {}
        for i in range(0, len(arr)):
            if (arr[i] in numFreq):
                numFreq[arr[i]] += 1
            else:
                numFreq[arr[i]] = 1
        arr.sort()
        res = []
        for i in range(0, len(arr)):
            freq = numFreq[arr[i]]
            if (freq > 0):
                res.append(arr[i])
                numFreq[arr[i]] -= 1
                twice = 2 * arr[i]
                numFreq[twice] -= 1
        return res

f = Solution()
print(f.Extract_Original())

Q7. -

class Solution:
    def Create_Matrix(self, n: int) -> list[list[int]]:
        if n <= 0:
            return []
        result = [[None for i in range(n)] for j in range(n)]

        xBeg = 0
        xEnd = n-1
        yBeg = 0
        yEnd = n-1
        current = 1
        while True:
            for i in range(yBeg,yEnd+1):
                result[xBeg][i] = current
                current += 1
            xBeg += 1
            if (xBeg > xEnd):
                break
            for i in range(xBeg,xEnd+1):
                result[i][yEnd] = current
                current += 1
            yEnd -= 1
            if (yEnd < yBeg):
                break
            for i in range(yEnd,yBeg-1,-1):
                result[xEnd][i] = current
                current += 1
            xEnd -= 1
            if (xEnd < xBeg):
                break
            for i in range(xEnd,xBeg-1,-1):
                result[i][yBeg] = current
                current += 1
            yBeg += 1
            if (yBeg > yEnd):
                break
        return result

f = Solution()
print(f.Create_Matrix())


Q8. - 

class Solution:
    def Multiply_Matrix(self, m_1: list[list[int]], m_2: list[list[int]]) -> list[list[int]]:
        r1, c1, c2 = len(m_1), len(m_1[0]), len(m_2[0])
        res = [[0] * c2 for _ in range(r1)]
        for i in range(r1):
            for j in range(c2):
                for k in range(c1):
                    res[i][j] += m_1[i][k] * m_2[k][j]
        return res

f = Solution()
print(f.Multiply_Matrix())