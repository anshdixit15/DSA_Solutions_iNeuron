Q1. -

class Solution:
    def Maximized_Sum(self, arr: list[int]) -> int:
        arr.sort()
        result = 0
        arr_l = len(arr)
        for i in range(0, arr_l -1, 2):
            result += arr[i]
        return result

f = Solution()
print(f.Maximized_Sum())

Q2. -

class Solution:

    def Eat_Candy(self, arr: list[int]) -> int:

        unique_candy = {}
        count = 0
        for i in arr:
            if i in unique_candy:
                unique_candy[i] += 1
            else:
                unique_candy[i] = i
                count += 1
        if count > len(arr)/2:
            candy_count = len(arr)//2
        else:
            candy_count = count
        return candy_count


f = Solution()
print(f.Eat_Candy())

Q3. - 

class Solution:
    def Harmonious_count(self, arr: list[int]) -> int:
        output = 0
        count = {}
        for el in arr:
            if el in count:
                count[el] += 1
            else:
                count[el] = 1
            inc_el = el + 1
            dec_el = el - 1
            if dec_el in count:
                output = max(output, count[el] + count[dec_el])
            if inc_el in count:
                output = max(output, count[el] + count[inc_el])
        return output


f = Solution()
print(f.Harmonious_count())

Q4. -

class Solution:
    def place_for_flower(self, flowerbed: list[int], n: int) -> bool:
        count = 1
        place = 0
        for i in range(len(flowerbed)):
            if flowerbed[i] == 0:
                count += 1
            else:
                place += (count - 1) // 2
                count = 0

        place += count // 2
        if place >= n:
            return True
        return False

f = Solution()
print(f.place_for_flower())

Q5. -

class Solution:
    def Maximum_product(self, arr: list[int]) -> int:
        arr.sort()
        l = len(arr)-1
        i = 0
        if len(arr)<=2:
            return []
        if len(arr)==3:
            return arr[i]*arr[i+1]*arr[i+2]
        else:
            if arr[i] < 0 and arr[i + 1] < 0:
                product_1 = arr[i] * arr[i + 1] * arr[l]
            else:
                product_1 = arr[i] * arr[i+1] * arr[i+2]

        product_2 = arr[l] * arr[l-1] * arr[l-2]
        max_product = max(product_1, product_2)
        return max_product


f = Solution()
print(f.Maximum_product())

Q6. -

class Solution:
    def find_target(self, arr: list[int], target: int) -> int:
        min = 0
        max = len(arr)

        for i in range(len(arr)):
            mid = (min + max) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                min = mid
            elif arr[mid] > target:
                max = mid

        return -1

f = Solution()
print(f.find_target())

Q7. -

class Solution:
    def Check_Monotonic(self, arr: list[int]) -> bool:
        return (all(arr[i] <= arr[i+1] for  i in range(len(arr)-1)) or
                all(arr[i] >= arr[i+1] for i in range(len(arr)-1)))

f = Solution()
print(f.Check_Monotonic())

Q8. -

nums = [0,10]

class Solution:

    def operation(self, arr: list[int], k: int) ->int:
        x = (-k, k)
        l = 0
        for i in arr:
            arr[l] = i + x[l]
        result = max(arr) - min(arr)
        return result

f = Solution()
print(f.operation())