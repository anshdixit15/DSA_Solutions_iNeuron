Q1. - 

class Solution:
    def Closest_Sum(self, arr: list[int], target: int) -> int:
        arr.sort()
        arr_len = len(arr)
        closest = arr[0] + arr[1] + arr[arr_len-1]

        for i in range(0, arr_len-2):
            l_p = i + 1
            r_p = arr_len - 1
            while l_p < r_p:
                current_sum = arr[i] + arr[l_p] + arr[r_p]
                if current_sum <= target:
                    l_p += 1
                else:
                    r_p -= 1
                if abs(closest - target) > abs(current_sum - target):
                    closest = current_sum
        return closest

f = Solution()
print(f.Closest_Sum())

Q4. -

class Solution:

    def find_target(self, arr: list[int], target: int) -> int:
        left = 0
        right = len(arr)
        while left < right:
            mid = (left + right) >> 1
            if arr[mid] >= target:
                right = mid
            else:
                left = mid + 1
        return left

f = Solution()
print(f.find_target())

Q5. - 

class Solution:
    def Add_One(self, arr: list[int]) -> list[int]:
        arr_length = len(arr)
        i = arr_length - 1

        while arr[i] == 9 and i >= 0:
            i -= 1
        if i == -1:
            result = [0] * (arr_length + 1)
            result[0] = 1
            return result

        result = [0] * arr_length
        result[i] = arr[i] + 1
        for x in range(i-1, -1, -1):
            result[x] = arr[x]
        return result

f = Solution()
print(f.Add_One())

Q6. -

class Solution:
    def Unique_One(self, arr: list[int]) -> int:

        value = arr[0]
        for i in range(1, len(arr)):
            value = value ^ arr[i]
        return value

f = Solution()
print(f.Unique_One())


Q7. - 

class Solution:
    def Generating_Range(self, arr: list[int], lower: int, upper: int) -> list[list[int]]:
        def put_pair(a, b):
            return [a, b] if a == b else [a, b]
        arr_len = len(arr)
        if arr_len == 0:
            return [put_pair(lower, upper)]
        result = []
        if arr[0] > lower:
            result.append(put_pair(lower, arr[0] - 1))
        for a, b in pairwise(arr):
            if b - a > 1:
                result.append(put_pair(a+1, b-1))
        if arr[-1] < upper:
            result.append(put_pair(arr[-1]+1, upper))
        return result


f = Solution()
print(f.Generating_Range())

Q8. -

class Solution:
    def Attend_Meeting(self, arr: list[int]) -> bool:
        arr = sorted(arr, key=lambda x:x[0])
        for i in range(len(arr)-1):
            if arr[i][0] < arr[i+1][0] and arr[i][1] < arr[i+1][1]:
                return True
            else:
                return False

f = Solution()
print(f.Attend_Meeting())