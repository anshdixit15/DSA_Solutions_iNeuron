Q3. -

class Solution:
    def Step_Required(self, word1: str, word2: str) -> int:
        x = len(word1)
        y = len(word2)
        if x < y:
            word1, word2, x, y = word2, word1, y, x
        d_1 = [0] * (x + 1)
        d_2 = [0] * (x + 1)
        for i in word1:
            for j in range(y):
                d_2[j+1] = d_1[j] + 1 if i == word2[j] else max(d_2[j], d_1[j+1])
            d_1, d_2 = d_2, d_1
        return x + y - 2 * d_1[y]


f = Solution()
print(f.Step_Required())

Q5. -

class Solution:
  def Compress_String(self, chars: list[str]) -> int:

    count = 1
    j = 0
    for i in range(1, len(chars) + 1):
      if i < len(chars) and chars[i] == chars[i - 1]:
        count += 1
      else:
        chars[j] = chars[i - 1]
        j += 1

        if count == 1:
          continue
        for ch in str(count):
          chars[j] = ch
          j += 1

        count = 1
    # chars.pop(j)
    # return chars #-> it will return ["a","2","b","c","3"]
    return j


chars = ["a","a","b","b","c","c","c"]

f = Solution()
print(f.Compress_String(chars))

Q6. -

class Solution:
  def Find_Anagram( self, s: str, p: str) -> list[int]:

    n = len(s)
    m = len(p)
    sorted_p = p
    sorted_p = list(sorted_p);
    sorted_p.sort()
    sorted_p = ' '.join([str(elem) for elem in sorted_p])

    result = []
    for i in range(0, n - m + 1):
      temp = s[i:i + m]
      temp = list(temp)
      temp.sort()
      temp = ' '.join([str(elem) for elem in temp])

      if sorted_p == temp:
        result.append(i)
    return result


f = Solution()
print(f.Find_Anagram())


Q7. - 

class Solution:
  def Decode_String(self, s: str) -> str:
    holder = ""
    detail = []
    num = 0
    for char in s:
      if char.isdigit():
        num = 10 * num + int(char)

      if char == '[':
        detail.append(num)
        detail.append(holder)
        num = 0
        holder = ""
      if char.isalpha():
        holder += char
      if char == ']':

        pre_curr_str = detail.pop()
        pre_curr_num = detail.pop()
        holder = pre_curr_str + (pre_curr_num * holder)

    if len(holder) > 105:
      return holder[:105]

    return holder


f = Solution()
print(f.Decode_String(s))

Q8. -

class Solution:
    def Swap_and_Match(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        else:
            lst = []
            for i in range(len(goal)):
                if s[i:i+1:1] != goal[i:i+1:1]:
                    lst.append(i)
                    lst.append(s[i:i+1:1])

        s = s[:lst[0]] + lst[3] + s[lst[0]+1:]
        s = s[:lst[2]] + lst[1] + s[lst[2]+1:]

        return s == goal


f = Solution()
print(f.Swap_and_Match())
