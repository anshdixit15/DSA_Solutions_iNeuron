Q1. -

class Solution:
   def Two_Sum_Index(self, arr: list[int], target:int) -> list[int]:
      if len(arr) < 2:
         return []
      else:
         compare_box = {}
         for i in range(len(arr)):
            if target - arr[i] in compare_box:
               return [compare_box[target - arr[i]], i]
            else:
               compare_box[arr[i]] = i

def get_indices(arr_list, target_num):
   f = Solution()
   print(f.Two_Sum_Index(arr_list, target_num))

Q2. -

class Solution:
    def remove_Element(self, nums: list[int], val: int) -> int:
        k = 0

        for i in range(len(nums)):
            if nums[i] == val:
                continue
            nums[k] = nums[i]
            k += 1

        return k

f = Solution()
print(f.remove_Element())

Q3. - 

class Solution:

    def Value_Index(self, arr: list[int], t_value: int) -> int:
        initial = 0
        last = len(arr)-1
        while initial < last:
            mid = (initial + last)//2
            if arr[mid] == t_value:
                return mid
            elif arr[mid] < t_value:
                initial = mid + 1
            else:
                last = mid - 1
        return last + 1

f = Solution()
print(f.Value_Index())

Q4. -

class Solution:
    def Add_One(self, arr: list[int]) -> list[int]:
        ind = len(arr)-1
        while (ind >= 0 and arr[ind] == 9):
            arr[ind] = 0
            ind -= 1
        if ind < 0:
            arr.insert(0,1)
        else:
            arr[ind]+=1

        return arr

def added_digits(arr_digit):
    f = Solution()
    print(f.Add_One(arr_digit))

Q5. -

class Solution:
    def Merger_Integers(self, nums1: list[int], m: int, nums2: list[int], n: int) -> list[int]:
        i = m-1
        j = n-1
        cur = (m+n)-1
        while j > -1:
            if i > -1 and nums1[i] >= nums2[j]:
                nums1[cur] = nums1[i]
                i -= 1
            else:
                nums1[cur] = nums2[j]
                j -= 1

            cur -= 1
        return nums1

def Merged_array_list(nums1, m, nums2, n):
    f = Solution()
    print(f.Merger_Integers(nums1, m, nums2, n))


Q6. -

lass Solution:
   def DuplicateDetector(self, arr: list[int]) -> bool:
      new_arr_set = set()
      for i in arr:
         if i in new_arr_set:
            return True
         new_arr_set.add(i)
      return False

def Get_Boolean_result(lst):
   f = Solution()
   print(f.DuplicateDetector(lst))


Q7. - 

class Solution:
   def move_zero(self, arr: list[int]) -> int:
      if len(arr) == 0:
         return []
      if len(arr) > 0:
         ezi = 0
         for i in range(len(arr)):
            if arr[i] != 0:
               arr[ezi] = arr[i]
               ezi += 1
         for j in range(ezi,len(arr)):
            arr[j] = 0
         return arr

def final_result(lst):
   replace = Solution()
   print(f"Final Result : {replace.move_zero(lst)}")

Q8. -

class Solution:
    def Error_Nums(self, arr: list[int]) -> list[int]:

        result = [0, 0]
        n_l = len(arr)
        counts = {}
        num = 0
        for i in range(n_l):
            num ^= (i + 1)
            if arr[i] in counts:
                result[0] = arr[i]
            else:
                counts[arr[i]] = 1
                num ^= arr[i]
        result[1] = num
        return result


def get_Error_Num(lst):
    f = Solution()
    print(f.Error_Nums(lst))